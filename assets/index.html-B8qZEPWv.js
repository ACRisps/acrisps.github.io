import{_ as e,c as i,b as a,o as l}from"./app-DG_R6l0q.js";const o={};function n(r,t){return l(),i("div",null,t[0]||(t[0]=[a('<table><thead><tr><th>设计原则</th><th>简介</th><th>重要程度</th></tr></thead><tbody><tr><td>单一职责原则<br>(Single Responsibility Principle, SRP)</td><td>类的职责要单一，不能将太多的职责放在一个类中</td><td>4⭐</td></tr><tr><td>开闭原则<br>(Open-Closed Principle, OCP)</td><td>软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能</td><td>5⭐</td></tr><tr><td>里氏代换原则<br>(Liskov Substitution Principle, LSP)</td><td>在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象</td><td>4⭐</td></tr><tr><td>依赖倒转原则<br>(Dependency Inversion Principle, DIP)</td><td>要针对抽象层编程，而不要针对具体类编程</td><td>5⭐</td></tr><tr><td>接口隔离原则<br>(Interface Segregation Principle, ISP)</td><td>使用多个专门的接口来取代一个统一的接口</td><td>2⭐</td></tr><tr><td>合成复用原则<br>(Composite Reuse Principle, CRP)</td><td>在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系</td><td>4⭐</td></tr><tr><td>迪米特法则<br>(Law of Demeter, LoD)</td><td>一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互</td><td>3⭐</td></tr></tbody></table><h3 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h3><ul><li>一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</li><li>类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。</li><li>单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</li></ul><h3 id="开闭原则" tabindex="-1"><a class="header-anchor" href="#开闭原则"><span>开闭原则</span></a></h3><ul><li>一个软件实体应当<strong>对扩展开放，对修改关闭</strong>。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</li><li>&quot;Software entities should be open for extension, but closed for modification.&quot;</li><li>抽象化是开闭原则的关键。</li><li>开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则（Principle of Encapsulation of Variation, EVP）要求找到系统的可变因素并将其封装起来。</li></ul><h3 id="里氏代换原则" tabindex="-1"><a class="header-anchor" href="#里氏代换原则"><span>里氏代换原则</span></a></h3><ul><li>如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o2都代换成o1时，程序P的行为没有变化，那么类型S是类型T的子类型。（If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.）</li><li>第二种更容易理解的定义方式如下：所有引用基类（父类）的地方必须能透明地使用其子类的对象</li><li>里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。</li><li>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li></ul><h3 id="依赖倒转原则" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则"><span>依赖倒转原则</span></a></h3><ul><li>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</li><li>简单说，就是要针对接口编程，不要针对实现编程</li><li>简单来说，依赖倒转原则就是指：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</li><li>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。</li></ul><h3 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h3><ul><li>客户端不应该依赖那些它不需要的接口（Clients should not be forced to depend upon interfaces that they do not use.）</li><li>注意，在该定义中的接口指的是所定义的方法。</li><li>另一种定义方法如下：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。（Once an interface has gotten too &#39;fat&#39; it needs to be split intosmaller and more specific interfaces so that any clients of theinterface will only know about the methods that pertain to them.）</li><li>使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li><li>可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为。</li></ul><h3 id="合成复用原则" tabindex="-1"><a class="header-anchor" href="#合成复用原则"><span>合成复用原则</span></a></h3><ul><li>尽量使用对象组合，而不是继承来达到复用的目的。</li><li>合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</li><li>在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承。 <ul><li>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）</li><li>组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ）</li></ul></li><li>组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</li></ul><h3 id="迪米特法则-最小知识原则" tabindex="-1"><a class="header-anchor" href="#迪米特法则-最小知识原则"><span>迪米特法则（最小知识原则）</span></a></h3><ul><li>迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP），它有多种定义方法，其中几种典型定义如下： <ul><li>不要和“陌生人”说话。（Don&#39;t talk to strangers.）</li><li>只与你的直接朋友通信。（Talk only toyour immediate friends.)</li><li>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。（Each unit should have only limited knowledge aboutother units: only units &quot;closely&quot; related to the current unit.）</li></ul></li><li>在迪米特法则中，对于一个对象，其朋友包括以下几类： <ul><li>当前对象本身(this)；</li><li>以参数形式传入到当前对象方法中的对象；</li><li>当前对象的成员对象；</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li><li>当前对象所创建的对象。</li><li>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。</li><li>当然，说得太具体就没意思了hh</li></ul></li><li>迪米特法则可分为狭义法则和广义法则。在狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</li><li>狭义的迪米特法则：可以降低类之间的耦合，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会造成系统的不同模块之间的通信效率降低，使得系统的不同模块之间不容易协调。</li><li>广义的迪米特法则：指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。</li><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>在 JDK 中，<code>java.util.Stack</code>是<code>java.util.Vector</code>类的子类，该设计合理吗？</p><p>其实不太合理，<code>Stack</code>和<code>Vector</code>在功能和语义上存在差异，参见里氏代换，接口隔离等。</p></div>',16)]))}const d=e(o,[["render",n]]),c=JSON.parse('{"path":"/article/cxjyx073/","title":"面向对象设计原则","lang":"zh-CN","frontmatter":{"title":"面向对象设计原则","createTime":"2025/03/05","permalink":"/article/cxjyx073/","description":"单一职责原则 一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象设计原则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-14T07:18:34.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://acrisps.github.io/article/cxjyx073/"}],["meta",{"property":"og:site_name","content":"Citrus Notes"}],["meta",{"property":"og:title","content":"面向对象设计原则"}],["meta",{"property":"og:description","content":"单一职责原则 一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-14T07:18:34.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-14T07:18:34.000Z"}]]},"readingTime":{"minutes":9.39,"words":2818},"git":{"updatedTime":1749885514000,"contributors":[{"name":"ChenYuLang","username":"ChenYuLang","email":"fmzcyl@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/ChenYuLang?v=4","url":"https://github.com/ChenYuLang"},{"name":"acrisps","username":"acrisps","email":"fmzcyl@163.com","commits":2,"avatar":"https://avatars.githubusercontent.com/acrisps?v=4","url":"https://github.com/acrisps"}]},"autoDesc":true,"filePathRelative":"Learn/软件系统设计/面向对象设计原则.md","headers":[],"categoryList":[{"id":"2f1a3e","sort":10000,"name":"Learn"},{"id":"1fd58e","sort":10001,"name":"软件系统设计"}]}');export{d as comp,c as data};
